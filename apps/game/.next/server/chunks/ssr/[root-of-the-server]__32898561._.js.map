{"version":3,"sources":["../../../../../../node_modules/lucide-react/src/icons/loader-circle.ts","../../../../../../node_modules/lucide-react/src/icons/chart-column.ts","../../../../../../apps/game/src/lib/api/client/ideas.ts","../../../../../../apps/game/src/hooks/use-ideas.ts","../../../../../../apps/game/src/lib/api/client/votes.ts","../../../../../../apps/game/src/hooks/use-votes.ts","../../../../../../apps/game/src/lib/api/client/comments.ts","../../../../../../apps/game/src/hooks/use-comments.ts","../../../../../../apps/game/src/hooks/index.ts","../../../../../../apps/game/src/lib/api/client/pivots.ts","../../../../../../apps/game/src/hooks/use-pivots.ts","../../../../../../apps/game/src/app/actions/data%3A0cbf89%20%3Ctext/javascript%3E","../../../../../../node_modules/lucide-react/src/icons/circle-check.ts","../../../../../../node_modules/lucide-react/src/icons/info.ts","../../../../../../node_modules/lucide-react/src/icons/triangle-alert.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [['path', { d: 'M21 12a9 9 0 1 1-6.219-8.56', key: '13zald' }]];\n\n/**\n * @component @name LoaderCircle\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEgMTJhOSA5IDAgMSAxLTYuMjE5LTguNTYiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/loader-circle\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst LoaderCircle = createLucideIcon('loader-circle', __iconNode);\n\nexport default LoaderCircle;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M3 3v16a2 2 0 0 0 2 2h16', key: 'c24i48' }],\n  ['path', { d: 'M18 17V9', key: '2bz60n' }],\n  ['path', { d: 'M13 17V5', key: '1frdt8' }],\n  ['path', { d: 'M8 17v-3', key: '17ska0' }],\n];\n\n/**\n * @component @name ChartColumn\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMyAzdjE2YTIgMiAwIDAgMCAyIDJoMTYiIC8+CiAgPHBhdGggZD0iTTE4IDE3VjkiIC8+CiAgPHBhdGggZD0iTTEzIDE3VjUiIC8+CiAgPHBhdGggZD0iTTggMTd2LTMiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/chart-column\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChartColumn = createLucideIcon('chart-column', __iconNode);\n\nexport default ChartColumn;\n","/**\n * API Client - Ideas\n * \n * Client-side functions to call ideas API routes.\n * Components should use hooks, not these functions directly.\n */\n\nimport type {\n  CreateIdeaRequest,\n  CreateIdeaResponse,\n  GetIdeasResponse,\n  GetIdeaResponse,\n} from \"@/types/api\";\n\nconst API_BASE = \"/api/ideas\";\n\n// Sort options type\ntype SortOption = \"votes_desc\" | \"votes_asc\" | \"created_desc\" | \"created_asc\";\n\n/**\n * Fetch paginated ideas list\n */\nexport async function fetchIdeas(params?: {\n  cursor?: string;\n  limit?: number;\n  sort?: SortOption;\n}): Promise<GetIdeasResponse> {\n  const searchParams = new URLSearchParams();\n  \n  if (params?.cursor) searchParams.set(\"cursor\", params.cursor);\n  if (params?.limit) searchParams.set(\"limit\", String(params.limit));\n  if (params?.sort) searchParams.set(\"sort\", params.sort);\n\n  const url = `${API_BASE}?${searchParams.toString()}`;\n  const response = await fetch(url);\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to fetch ideas\");\n  }\n\n  return response.json();\n}\n\n/**\n * Fetch a single idea by ID\n */\nexport async function fetchIdea(id: string): Promise<GetIdeaResponse> {\n  const response = await fetch(`${API_BASE}/${id}`);\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to fetch idea\");\n  }\n\n  return response.json();\n}\n\n/**\n * Create a new idea\n */\nexport async function createIdea(\n  data: CreateIdeaRequest\n): Promise<CreateIdeaResponse> {\n  const response = await fetch(API_BASE, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(data),\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to create idea\");\n  }\n\n  return response.json();\n}\n\n/**\n * Update an idea\n */\nexport interface UpdateIdeaRequest {\n  title?: string;\n  description?: string;\n}\n\nexport async function updateIdea(id: string, data: UpdateIdeaRequest): Promise<GetIdeaResponse> {\n  const response = await fetch(`${API_BASE}/${id}`, {\n    method: \"PATCH\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(data),\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to update idea\");\n  }\n\n  return response.json();\n}\n\n/**\n * Delete an idea\n */\nexport async function deleteIdea(id: string): Promise<void> {\n  const response = await fetch(`${API_BASE}/${id}`, {\n    method: \"DELETE\",\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to delete idea\");\n  }\n}\n\n","/**\n * Ideas Hooks\n * \n * TanStack Query hooks for ideas.\n * Components should use ONLY these hooks for data fetching.\n */\n\n\"use client\";\n\nimport {\n  useQuery,\n  useMutation,\n  useQueryClient,\n  useInfiniteQuery,\n} from \"@tanstack/react-query\";\nimport {\n  fetchIdeas,\n  fetchIdea,\n  createIdea,\n  updateIdea,\n  deleteIdea,\n} from \"@/lib/api/client/ideas\";\nimport type { UpdateIdeaRequest } from \"@/lib/api/client/ideas\";\nimport { toast } from \"sonner\";\nimport type { CreateIdeaRequest } from \"@/types/api\";\n\n// Sort options type\nexport type SortOption = \"votes_desc\" | \"votes_asc\" | \"created_desc\" | \"created_asc\";\n\n// Query keys for cache management\nexport const ideaKeys = {\n  all: [\"ideas\"] as const,\n  lists: () => [...ideaKeys.all, \"list\"] as const,\n  list: (filters: Record<string, unknown>) =>\n    [...ideaKeys.lists(), filters] as const,\n  details: () => [...ideaKeys.all, \"detail\"] as const,\n  detail: (id: string) => [...ideaKeys.details(), id] as const,\n};\n\n/**\n * Hook for fetching paginated ideas with infinite scroll\n */\nexport function useIdeas(params?: {\n  sort?: SortOption;\n  limit?: number;\n}) {\n  return useInfiniteQuery({\n    queryKey: ideaKeys.list({ sort: params?.sort }),\n    queryFn: ({ pageParam }) =>\n      fetchIdeas({\n        cursor: pageParam,\n        limit: params?.limit ?? 20,\n        sort: params?.sort,\n      }),\n    getNextPageParam: (lastPage) =>\n      lastPage.hasMore ? lastPage.nextCursor : undefined,\n    initialPageParam: undefined as string | undefined,\n    staleTime: 30 * 1000, // 30 seconds\n  });\n}\n\n/**\n * Hook for fetching a single idea\n */\nexport function useIdea(id: string) {\n  return useQuery({\n    queryKey: ideaKeys.detail(id),\n    queryFn: () => fetchIdea(id),\n    staleTime: 30 * 1000,\n    enabled: !!id && id !== \"undefined\",\n  });\n}\n\n/**\n * Hook for creating a new idea\n */\nexport function useCreateIdea() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: CreateIdeaRequest) => createIdea(data),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ideaKeys.lists() });\n      toast.success(\"Idea created!\");\n    },\n    onError: (err) => {\n      if (err.message?.includes(\"Unauthorized\") || err.message?.includes(\"401\")) {\n        toast.error(\"Please sign in to create ideas\");\n      } else {\n        toast.error(err.message || \"Failed to create idea\");\n      }\n    },\n  });\n}\n\n/**\n * Hook for updating an idea\n */\nexport function useUpdateIdea(id: string) {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: UpdateIdeaRequest) => updateIdea(id, data),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ideaKeys.detail(id) });\n      queryClient.invalidateQueries({ queryKey: ideaKeys.lists() });\n      toast.success(\"Idea updated!\");\n    },\n    onError: (err) => {\n      if (err.message?.includes(\"Forbidden\") || err.message?.includes(\"403\")) {\n        toast.error(\"You don't have permission to edit this idea\");\n      } else {\n        toast.error(err.message || \"Failed to update idea\");\n      }\n    },\n  });\n}\n\n/**\n * Hook for deleting an idea\n */\nexport function useDeleteIdea() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (id: string) => deleteIdea(id),\n    onSuccess: (_, id) => {\n      queryClient.removeQueries({ queryKey: ideaKeys.detail(id) });\n      queryClient.invalidateQueries({ queryKey: ideaKeys.lists() });\n      toast.success(\"Idea deleted\");\n    },\n    onError: (err) => {\n      if (err.message?.includes(\"Forbidden\") || err.message?.includes(\"403\")) {\n        toast.error(\"You don't have permission to delete this idea\");\n      } else {\n        toast.error(err.message || \"Failed to delete idea\");\n      }\n    },\n  });\n}\n\n","/**\n * API Client - Votes\n * \n * Client-side functions to call votes API routes.\n * Components should use hooks, not these functions directly.\n */\n\nimport type { CastVoteRequest, CastVoteResponse, RemoveVoteResponse } from \"@/types/api\";\n\n/**\n * Cast or update a vote on an idea\n */\nexport async function castVote(\n  ideaId: string,\n  data: CastVoteRequest\n): Promise<CastVoteResponse> {\n  const response = await fetch(`/api/ideas/${ideaId}/vote`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(data),\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to vote\");\n  }\n\n  return response.json();\n}\n\n/**\n * Remove a vote from an idea\n */\nexport async function removeVote(ideaId: string): Promise<RemoveVoteResponse> {\n  const response = await fetch(`/api/ideas/${ideaId}/vote`, {\n    method: \"DELETE\",\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to remove vote\");\n  }\n\n  return response.json();\n}\n","/**\n * Votes Hooks\n * \n * TanStack Query hooks for votes.\n * Components should use ONLY these hooks for voting.\n */\n\n\"use client\";\n\nimport { useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { castVote, removeVote } from \"@/lib/api/client/votes\";\nimport { ideaKeys } from \"./use-ideas\";\nimport { toast } from \"sonner\";\nimport type { IdeaWithDetails } from \"@/types/database\";\n\n/**\n * Hook for casting/updating a vote with optimistic updates\n */\nexport function useVote(ideaId: string) {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (value: 1 | -1) => castVote(ideaId, { value }),\n    \n    // Optimistic update\n    onMutate: async (newValue) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ideaKeys.detail(ideaId) });\n      await queryClient.cancelQueries({ queryKey: ideaKeys.lists() });\n\n      // Snapshot previous value\n      const previousIdea = queryClient.getQueryData<{ data: IdeaWithDetails }>(\n        ideaKeys.detail(ideaId)\n      );\n\n      // Optimistically update the detail cache\n      if (previousIdea) {\n        const oldVote = previousIdea.data.user_vote?.value;\n        let upvotesDelta = 0;\n        let downvotesDelta = 0;\n\n        if (oldVote === 1 && newValue === -1) {\n          upvotesDelta = -1;\n          downvotesDelta = 1;\n        } else if (oldVote === -1 && newValue === 1) {\n          upvotesDelta = 1;\n          downvotesDelta = -1;\n        } else if (!oldVote && newValue === 1) {\n          upvotesDelta = 1;\n        } else if (!oldVote && newValue === -1) {\n          downvotesDelta = 1;\n        }\n\n        queryClient.setQueryData(ideaKeys.detail(ideaId), {\n          data: {\n            ...previousIdea.data,\n            upvotes_count: previousIdea.data.upvotes_count + upvotesDelta,\n            downvotes_count: previousIdea.data.downvotes_count + downvotesDelta,\n            user_vote: { value: newValue } as IdeaWithDetails[\"user_vote\"],\n          },\n        });\n      }\n\n      return { previousIdea };\n    },\n\n    // Rollback on error\n    onError: (err, _newValue, context) => {\n      if (context?.previousIdea) {\n        queryClient.setQueryData(ideaKeys.detail(ideaId), context.previousIdea);\n      }\n      // Check for unauthorized - likely session expired\n      if (err.message?.includes(\"Unauthorized\") || err.message?.includes(\"401\")) {\n        toast.error(\"Please sign in to vote\");\n      } else {\n        toast.error(err.message || \"Failed to vote\");\n      }\n    },\n\n    // Refetch after mutation\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: ideaKeys.detail(ideaId) });\n      queryClient.invalidateQueries({ queryKey: ideaKeys.lists() });\n    },\n  });\n}\n\n/**\n * Hook for removing a vote with optimistic updates\n */\nexport function useRemoveVote(ideaId: string) {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: () => removeVote(ideaId),\n\n    onMutate: async () => {\n      await queryClient.cancelQueries({ queryKey: ideaKeys.detail(ideaId) });\n\n      const previousIdea = queryClient.getQueryData<{ data: IdeaWithDetails }>(\n        ideaKeys.detail(ideaId)\n      );\n\n      if (previousIdea && previousIdea.data.user_vote) {\n        const oldVote = previousIdea.data.user_vote.value;\n\n        queryClient.setQueryData(ideaKeys.detail(ideaId), {\n          data: {\n            ...previousIdea.data,\n            upvotes_count:\n              previousIdea.data.upvotes_count - (oldVote === 1 ? 1 : 0),\n            downvotes_count:\n              previousIdea.data.downvotes_count - (oldVote === -1 ? 1 : 0),\n            user_vote: null,\n          },\n        });\n      }\n\n      return { previousIdea };\n    },\n\n    onError: (err, _, context) => {\n      if (context?.previousIdea) {\n        queryClient.setQueryData(ideaKeys.detail(ideaId), context.previousIdea);\n      }\n      toast.error(err.message || \"Failed to remove vote\");\n    },\n\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: ideaKeys.detail(ideaId) });\n      queryClient.invalidateQueries({ queryKey: ideaKeys.lists() });\n    },\n  });\n}\n","/**\n * API Client - Comments\n * \n * Client-side functions to call comments API routes.\n * Components should use hooks, not these functions directly.\n */\n\nimport type {\n  CreateCommentRequest,\n  CreateCommentResponse,\n  GetCommentsResponse,\n} from \"@/types/api\";\n\n/**\n * Fetch paginated comments for an idea\n */\nexport async function fetchComments(\n  ideaId: string,\n  params?: { cursor?: string; limit?: number }\n): Promise<GetCommentsResponse> {\n  const searchParams = new URLSearchParams();\n  \n  if (params?.cursor) searchParams.set(\"cursor\", params.cursor);\n  if (params?.limit) searchParams.set(\"limit\", String(params.limit));\n\n  const url = `/api/ideas/${ideaId}/comments?${searchParams.toString()}`;\n  const response = await fetch(url);\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to fetch comments\");\n  }\n\n  return response.json();\n}\n\n/**\n * Create a new comment on an idea\n */\nexport async function createComment(\n  ideaId: string,\n  data: CreateCommentRequest\n): Promise<CreateCommentResponse> {\n  const response = await fetch(`/api/ideas/${ideaId}/comments`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(data),\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to create comment\");\n  }\n\n  return response.json();\n}\n\n/**\n * Delete a comment\n */\nexport async function deleteComment(\n  ideaId: string,\n  commentId: string\n): Promise<void> {\n  const response = await fetch(`/api/ideas/${ideaId}/comments/${commentId}`, {\n    method: \"DELETE\",\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to delete comment\");\n  }\n}\n","/**\n * Comments Hooks\n * \n * TanStack Query hooks for comments.\n * Components should use ONLY these hooks for comments.\n */\n\n\"use client\";\n\nimport {\n  useInfiniteQuery,\n  useMutation,\n  useQueryClient,\n} from \"@tanstack/react-query\";\nimport {\n  fetchComments,\n  createComment,\n  deleteComment,\n} from \"@/lib/api/client/comments\";\nimport { ideaKeys } from \"./use-ideas\";\nimport { toast } from \"sonner\";\nimport type { CreateCommentRequest } from \"@/types/api\";\n\n// Query keys for comments\nexport const commentKeys = {\n  all: [\"comments\"] as const,\n  lists: () => [...commentKeys.all, \"list\"] as const,\n  list: (ideaId: string) => [...commentKeys.lists(), ideaId] as const,\n};\n\n/**\n * Hook for fetching paginated comments for an idea\n */\nexport function useComments(ideaId: string, params?: { limit?: number }) {\n  return useInfiniteQuery({\n    queryKey: commentKeys.list(ideaId),\n    queryFn: ({ pageParam }) =>\n      fetchComments(ideaId, {\n        cursor: pageParam,\n        limit: params?.limit ?? 20,\n      }),\n    getNextPageParam: (lastPage) =>\n      lastPage.hasMore ? lastPage.nextCursor : undefined,\n    initialPageParam: undefined as string | undefined,\n    staleTime: 30 * 1000,\n    enabled: !!ideaId && ideaId !== \"undefined\",\n  });\n}\n\n/**\n * Hook for creating a new comment\n */\nexport function useCreateComment(ideaId: string) {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: CreateCommentRequest) => createComment(ideaId, data),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: commentKeys.list(ideaId) });\n      queryClient.invalidateQueries({ queryKey: ideaKeys.detail(ideaId) });\n      queryClient.invalidateQueries({ queryKey: ideaKeys.lists() });\n    },\n    onError: (err) => {\n      if (err.message?.includes(\"Unauthorized\") || err.message?.includes(\"401\")) {\n        toast.error(\"Please sign in to comment\");\n      } else {\n        toast.error(err.message || \"Failed to add comment\");\n      }\n    },\n  });\n}\n\n/**\n * Hook for deleting a comment\n */\nexport function useDeleteComment(ideaId: string) {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (commentId: string) => deleteComment(ideaId, commentId),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: commentKeys.list(ideaId) });\n      queryClient.invalidateQueries({ queryKey: ideaKeys.detail(ideaId) });\n      queryClient.invalidateQueries({ queryKey: ideaKeys.lists() });\n      toast.success(\"Comment deleted\");\n    },\n    onError: (err) => {\n      toast.error(err.message || \"Failed to delete comment\");\n    },\n  });\n}\n","/**\n * Hooks Index\n * \n * Exports all hooks for use in components.\n */\n\nexport * from \"./use-ideas\";\nexport * from \"./use-votes\";\nexport * from \"./use-comments\";\nexport * from \"./use-auth\";\nexport * from \"./use-pivots\";\nexport * from \"./use-collaborators\";\n","/**\n * API Client - Pivots & Version History\n */\n\nimport type {\n  CreatePivotRequest,\n  CreatePivotResponse,\n  GetVersionHistoryResponse,\n} from \"@/types/api\";\n\n/**\n * Create a pivot (version snapshot + optional update)\n */\nexport async function createPivot(\n  ideaId: string,\n  data: CreatePivotRequest\n): Promise<CreatePivotResponse> {\n  const response = await fetch(`/api/ideas/${ideaId}/pivot`, {\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(data),\n  });\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to create pivot\");\n  }\n\n  return response.json();\n}\n\n/**\n * Fetch version history for an idea\n */\nexport async function fetchVersionHistory(\n  ideaId: string\n): Promise<GetVersionHistoryResponse> {\n  const response = await fetch(`/api/ideas/${ideaId}/history`);\n\n  if (!response.ok) {\n    const error = await response.json();\n    throw new Error(error.message || \"Failed to fetch version history\");\n  }\n\n  return response.json();\n}\n","\"use client\";\n\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { createPivot, fetchVersionHistory } from \"@/lib/api/client/pivots\";\nimport { toast } from \"sonner\";\nimport { ideaKeys } from \"./use-ideas\";\nimport type { CreatePivotRequest } from \"@/types/api\";\n\nexport const pivotKeys = {\n  history: (ideaId: string) => [...ideaKeys.detail(ideaId), \"history\"] as const,\n};\n\n/**\n * Hook to fetch version history for an idea\n */\nexport function useVersionHistory(ideaId: string) {\n  return useQuery({\n    queryKey: pivotKeys.history(ideaId),\n    queryFn: () => fetchVersionHistory(ideaId),\n    enabled: !!ideaId,\n  });\n}\n\n/**\n * Hook to create a pivot\n */\nexport function useCreatePivot(ideaId: string) {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: CreatePivotRequest) => createPivot(ideaId, data),\n    onSuccess: () => {\n      // Invalidate related queries\n      queryClient.invalidateQueries({ queryKey: ideaKeys.detail(ideaId) });\n      queryClient.invalidateQueries({ queryKey: pivotKeys.history(ideaId) });\n      queryClient.invalidateQueries({ queryKey: ideaKeys.all });\n      \n      toast.success(\"Pivot created successfully!\");\n    },\n    onError: (err: Error) => {\n      toast.error(err.message || \"Failed to create pivot\");\n    },\n  });\n}\n","/* __next_internal_action_entry_do_not_use__ [{\"001f1bd6b1b941ab921a271cfb25953d421d24e12a\":\"checkIsAdmin\"},\"apps/game/src/app/actions/admin-actions.ts\",\"\"] */\"use turbopack no side effects\";import{createServerReference,callServer,findSourceMapURL}from\"private-next-rsc-action-client-wrapper\";const $$RSC_SERVER_ACTION_0=/*#__PURE__*/createServerReference(\"001f1bd6b1b941ab921a271cfb25953d421d24e12a\",callServer,void 0,findSourceMapURL,\"checkIsAdmin\");export{$$RSC_SERVER_ACTION_0 as checkIsAdmin};","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],\n  ['path', { d: 'm9 12 2 2 4-4', key: 'dzmm74' }],\n];\n\n/**\n * @component @name CircleCheck\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgLz4KICA8cGF0aCBkPSJtOSAxMiAyIDIgNC00IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/circle-check\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst CircleCheck = createLucideIcon('circle-check', __iconNode);\n\nexport default CircleCheck;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['circle', { cx: '12', cy: '12', r: '10', key: '1mglay' }],\n  ['path', { d: 'M12 16v-4', key: '1dtifu' }],\n  ['path', { d: 'M12 8h.01', key: 'e9boi3' }],\n];\n\n/**\n * @component @name Info\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCIgLz4KICA8cGF0aCBkPSJNMTIgMTZ2LTQiIC8+CiAgPHBhdGggZD0iTTEyIDhoLjAxIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/info\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Info = createLucideIcon('info', __iconNode);\n\nexport default Info;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'm21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3',\n      key: 'wmoenq',\n    },\n  ],\n  ['path', { d: 'M12 9v4', key: 'juzpu7' }],\n  ['path', { d: 'M12 17h.01', key: 'p32p05' }],\n];\n\n/**\n * @component @name TriangleAlert\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMjEuNzMgMTgtOC0xNGEyIDIgMCAwIDAtMy40OCAwbC04IDE0QTIgMiAwIDAgMCA0IDIxaDE2YTIgMiAwIDAgMCAxLjczLTMiIC8+CiAgPHBhdGggZD0iTTEyIDl2NCIgLz4KICA8cGF0aCBkPSJNMTIgMTdoLjAxIiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/triangle-alert\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst TriangleAlert = createLucideIcon('triangle-alert', __iconNode);\n\nexport default TriangleAlert;\n"],"names":[],"mappings":"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","ignoreList":[1]}